# LibCanvas.App.Element

`LibCanvas.App.Element` - абстрактний клас-каркас для створення елементів, які будуть відрисовуватися.

На відміну від інших класів LibCanvas, цей використовується виключно через наслідування.
Наш інструмент - його перевизначення і створення власних методів в класі-нащадку:

```js

atom.declare('Unit', App.Element, {
	renderTo: function (ctx, resources) {
		ctx.fill(this.shape, 'red');
	}
});

new Unit(layer, {
	shape: new Circle(100, 100, 50)
});

```

### Вбудовані методи і властивості

`atom.Events events` - об'єкт, який слухає події
`atom.Settings settings` - об'єкт з налаштуваннями. Основні властивості:
	* `zIndex` - порядок відрисовки елемента
	* `shape` - фігура, яка визначає елемент
	* `hidden` (*boolean*) - приховує або відображає елемент. Приховання через `hidden` є кращим, ніж пуста відрисовка, бо елемент не приймає участі в підрахунку колізій і не стирається його попереднє положення.

#### `redraw`

`LibCanvas.App.Element redraw()`

Мктод, який повідомляє додаток, що елемент змінився.
Увага! Сам метод нічого не перерисовує. Він тільки ставить елемент в чергу на відрисовку.
Виклик елементів дуже швидкий і може безболісно повторюватися багато разів за кадр.
Контекст методу прив'язаний до елемента так, що може бути переданий в якості колбеку без втрати контексту.

```js
animate(element, {
	color: 'red',
	onChange: element.redraw
})
```

#### `destroy`

`LibCanvas.App.Element destroy()`

Видаляє елемент із контесту (але не відписує його від подій мишки, якщо він був підписаний через mouseHandler!).
Контекст методу прив'язаний до елемента так, що може бути переданий в якості колбеку без втрати контексту.

```js
destroyButton.onclick = element.destroy;
```

### Методи для перевизначення

#### `renderTo`

```js
void renderTo(LibCanvas.Context2D ctx, atom.Registry resources)
```

Відрисовує елемент в контекст. Описуйте в цьому методі тільки відрисовку, а не зміни об'єкта!
За замовчуванням викликає метод `renderTo` з властивості `renderer` (якщо є) або нічого не робить.

```js

atom.declare('Unit', App.Element, {
	renderTo: function (ctx, resources) {
		ctx.fill(this.shape, 'red');
		ctx.stroke(this.shape, 'blue');
	}
});

```

#### `configure`

```js
void configure()
```

Викликається зразу після побудови. Використовується в нащадках `App.Element` замість конструктора.

#### `get currentBoundingShape`

Повертає фігуру, яка описує вплив елемента на контекст.
За замовчуванням - прямокутник, в який вкладений `shape` елемента.

#### `isTriggerPoint`

```js
boolean isTriggerPoint(Point point)
```

Визначає чи є точка точкою спрацювання для мишки або іншого пристрою введення.
За замовчуванням - перевіряє на належність `shape`.

#### `onUpdate`

```js
void onUpdate(int time)
```

Якщо шар має включений `invoke`, то викликається кожен кадр і служить для зміни властивостей об'єкта відповідно до часу.
В аргументі `time` передається час в мілісекундах, який пройшов з моменту останнього кадру, для корекції і незалежності швидкості додатку від FPS.

```js

atom.declare('Unit', App.Element, {
	onUpdate: function (time) {
		// обертається зі швидкістю 90 градусів за секунду
		this.rotate((90).degree() * time / 1000);

		// зміни відбуваються на кожному кадрі, тому завжди викликаємо відрисовку
		this.redraw();
	}
});
```

#### `clearPrevious`

```js
void clearPrevious(LibCanvas.Context2D ctx)
```

Очищає попереднє розміщення елемента в `ctx`.
За замовчуванням - стирає `this.previousBoundingShape`.

#### `distanceMove`

```js
void distanceMove(LibCanvas.Point point)
```

Зміщує елемент на відстань `point`.
Використовується, наприклад, в `App.Draggable`.
